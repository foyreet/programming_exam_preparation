1. l-value и r-value
r-value: x + y + z ; x++; читается справа налево (x + y) + z
l-value: x += y; ++x; читается слева направо x += (y += z)

2. nullptr, NULL, 0
nullptr 0 в указателях. Ключевое слово
NULL - макрос, константа равная 0
0 - это 0

3. Алгоритм бинарного поиска
1) В отсортированном массиве.
2) Сравнение искомого элемента с центральным.
3) Рекурсивный поиск в "подходящей половине"

13. АТД матрица
 - создание, уничтожение, копирование
 - Получение доступа к элементу по индексу
 - Получение размера
 - Изменение размера
 - печать

 49 Инвариант типа
 1) состояние экземпляра
 - Значения всех переменных
 - Может изменяться методами
 - Может изменяться прямым изменением полей
 2) Определяется типом
 3) Должен выполняться в начале и в конце каждого метода
 4) Может контролироваться assert

 75-76 Контейнер
  Контейнер
  - содержит свои элементы
  - является регулярным типом (если элементы регулярного типа)
  - предоставляет доступ к элементам
  Свойства:
  1) элемент принадлежит не более чем 1-ому контейнеру(семантика значений)
  - контейнеры не пересекаются
  - ограничение на объекты, а не на значения
  2) время жизни элемента не превышает время жизни контейнера
  - создаётся не раньше
  - уничтожается не позже
  Иерархия концепций контейнеров
  - контейнер произвольного доступа
  - реверсивный контейнер
  - однонаправленный контейнер
  - контейнер(итератор ввода)

 Примеры контейнеров:
  vector, set, map, deque, stack, queue

7. Алфавит и идентификатор
Алфавит - прописные буквы, _ , 0 - 9 , спец.знаки ? {} , [] () + - ,пробельные символы: пробел, символы табуляции
Идентификатор - имя объекта (не может начинаться с цифры) пример int numbers (пробелы внутри имён не допускаются)
Не должен совпадать с ключевыми словами
8. Арифметика указателей
(i + 1) увеличение адреса на 4 байт
9. АТД(абстрактные типы данных)
    1) описывает набор операций
    - создание/уничтожение
    - изменение
    - получение описания
    Примеры атд(число, строка, массив, стек, очередь)

    Структура данных(способ организации и манипуляции данными)
    - реализация АТД
    Примеры: кортеж, массив, список, дерево, граф
10 АТД стек и варианты реализации
1) push - добавить
2) pop - удалить
3) peek - посмотреть элемент
11.АТД дэк и варианты реализации
смотри файл 11_deque.cpp

12. АТД массив и варианты реализации
файл 12_array.cpp

14 АТД множество и варианты реализации
set - Контейнер, содержащий неповторяющиеся элементы в произвольном порядке
Реализация хэш - таблица, бинарное дерево поиска
Операции:
1) Добавление элемента в множество
2) Удаление элемента из множества
3) Проверка наличия элемента в множестве
4) Объединение двух множеств
5) Пересечение 2 - ух множеств
6) Разность 2 - ух множеств

15 АТД очередь с приоритетом и варианты реализации
Очередь с приоритетом - Коллекция элементов, где каждый элемент имеет связанный с ним приоритет.
Элемент с высшим приоритетом будет обрабатываться раньше, чем элементы с более низким приоритетом.
Операции:
1) Вставка элемента с приоритетом
2) Удаление элемента из очереди с наивысшим приоритетом
3) Просмотр элемента с высшим приоритетом
4) Поиск элемента с определённым приоритетом
Реализации массивы, связные списки, древовидные структуры

16 АТД очередь и варианты реализации
Элементы кладутся и забираются с разных концов (First-in-First-Out) первый вошёл, первый вышел
Можно реализовать с помощью связного списка
1) Enqueue - Добавление элемента в очередь
2) Dequeue - Удаление элемента из очереди
3) Peek - возвращение 1 - ого элемента
4) Count - количество элементов в очереди

17 АТД полином и так понятно

18 АТД словарь и варианты реализации
ассоциативный массив, позволяющий хранить пары вида "ключ - значение"
Можно реализовать с помощью хэш - таблиц
Операции:
1) Добавление нового элемента с уникальным ключом O(1)
2) Удаление элемента по ключу O(1)
3) Изменение значения по ключу O(1)
4) Получение значения по ключу O(1)

19 АТД строка и варианты реализации
]

22 Бесконечные циклы
while(true) {

}
23 Библиотека(library) и каркас(framework)
Я использую библиотеку, а фреймворк использует мой код

24 Динамическая библиотека
Лежит изначально в оперативной памяти(должна быть установлена на моём компьютере)
И я могу вытаскивать функции из этой динамической библиотеки
.dll - в виндоусе
25 Статическая библиотека
Библиотеки которые идут вместе с кодом они лежат в файле a.out
Загружается в оперативную память

26 Буферизация при использовании потоков
Для записи и чтения используется буфер, который освобождается при переполнении или по требованию
strm.flush()
#include <streambuf> - для использования буферов

31 Ввод и вывод неформатированный
Неформатированный ввод:
- чтение отдельного символа или последовательности из потока
- put(записать в поток отдельный символ)
- get(прочитать из потока отдельный символ)
Неформатированный вывод:
- вывод отдельного символа или последовательности в поток
- write(записать в поток последовательность)
- read(прочитать из потока последовательность)

32 Вывод и ввод позиционирование


33 Вывод и ввод потоки
ввод - запрос последовательности символов и преобразование её в объект
вывод - преобразование объектов в последовательность символов
istream - ввод
ostream - вывод
iostream - ввод и вывод
33. вывод и ввод, потоки
<iostream> - стандартные потоки
<fstream> - файловые потоки (поток доставляет код в файл)
<sstream> - строковые потоки

34 ввод и вывод, файловые потоки
<fstream> поток доставляет код в файл


35 ввод и вывод форматированный
std::cout << "Форматированный вывод метод setw: " <<std::setw(10) << a << '\n'; // устанавливает ширину поля вывода
std::cout << "Форматированный вывод метод setprecision: " << std::setprecision(3) << pi << '\n'; // устанавливает точность вывода

111 Потоки стандартные
- Глобальные переменные (cout)
- возможно перенаправление
- cin и cout
- cerr(протоколирование ошибок)
- clog(ведение логов)

operator<< - запись в поток
operator>> - чтение из потока


78 Логирование (инструмент отладки)
1) добавление в код отписывания сообщений
- принятые решения
Логирование в больших проектах
1) использовать специальные библиотеки
- удалённая отладка

89 Объект
- непрерывная область в памяти
- значение типа

83 Модель памяти
1) непрерывная память
- адрес - сдвиг относительно начала
- байт - единица адресации

122. Связывание
- соотнесение вызова функции с телом функции
- раннее связывание(реализуется компилятором и компоновщиком до запуска программы)
Вся необходимая информация для того, чтобы определить,
какая именно функция будет вызвана, известна на этапе компиляции программы
Например:
стандартные вызовы функций, вызовы перегруженных функций и перегруженных операторов
- позднее связывание(осуществляется в процессе исполнения программы в зависимости от фактического типа экземпляра)
Объект связывается с вызовом функции только во время исполнения программы
Например:
виртуальные функции, производные классы
(Позднее связывание является одним из самых мощных добавлений языка С++ к возможностям языка С)

36 Выражение
Выражение - это комбинация операндов и операторов
a + b (a, b) - операнды  + - оператор
Описать виды выражений

37 Выражения - приоритеты и порядок вычисления
* / > + -
Арифметические операторы(+ -) > операторы сравнения( < ==) > логические операторы(&& ||)

39 Деструктор
Каждый класс содержит единственный деструктор
Это метод класса который вызывается при уничтожении объекта
Обратный порядок вызова конструкторов
Деструкторы полей
Деструкторы базового типа
~Complex() {}

40 Диапазоны арифметических типов
char 1 байт (-2^7 ; 2^7 - 1)
unsigned char 1 байт (0, 2^8 - 1)
int 4 байта (-2^31;2^31 - 1)
long 4 байта (-2^31;2^31 - 1)
long long 8 байт (-2^63 ; 2^63 - 1)
short 2 байта (-2^15 ; 2^15 - 1)
float 4 байта (-2^31;2^31 - 1)
double 8 байт (-2^63 ; 2^63 - 1)
unsigned int (0 ; 2^32 - 1)
unsigned long long (0; 2^64 - 1)

41 Диапазон и операции над ними
диапазон задаётся начальным и конечным итератором
std::sort(v.begin(), v.end())

42 Динамическое управление памятью
Оператор: new int - выделяет память для объекта, delete - освободить память
для массива: new int[4]     delete[] a;

46 Заголовочные файлы практика использования
Заголовочные файлы содержат интерфейсы (объявления классов, функций, структур) без их реализации (.h)
#include "example.h"
128 Стражи включения
Предотвращение повторного определения
препроцессорные директивы
(#ifdef, #ifndef, #define, #endif) позволяют включать или исключать части кода
#ifdef M_sum если M_sum определён то код включается
 Код
#endif
Код будет включён в компиляцию
#ifndef M_sum если M_sum не определён то код включается
#define M_sum // создаёт защиту от многократного включения
 Код
#endif

47 Закон дырявых абстракций
Все нетривиальные абстракции дырявы (Джоэл Сполски)
Программирование требует построения и использования абстракций

48 Замещение метода
Подклассу (наследнику) предоставить свою реализацию метода, который уже был определен в его базовом классе
1) Метод в подклассе должен иметь ту же сигнатуру (тип возвращаемого значения, название метода и параметры),
что и метод в базовом классе.
2) Быть методом виртуальной функции в базовом классе: Метод в базовом классе должен быть объявлен
как виртуальный с использованием ключевого слова virtual
3) В подклассе для явного указания на замещение метода используется ключевое слово override.

#include <iostream>

class Base {
public:
    // Виртуальная функция в базовом классе
    virtual void show() {
        std::cout << "Base::show()" << std::endl;
    }
};

class Derived : public Base {
public:
    // Замещение метода в подклассе
    void show() override {
        std::cout << "Derived::show()" << std::endl;
    }
};

49 Инвариант типа
 Инвариант типа - это условие, которое должно сохраняться для всех экземпляров определённого типа данных
 в течение их жизни. Эти условия обычно определяются для обеспечения корректности и безопасности программы.
Если нарушается инвариант типа, то
Например:
Инвариант типа для массива - это положительность размера массива

51 Инкремент и декремент
Инкремент
x++(постфиксный) сначала возвращается текущее значение x, а затем увеличивается на 1.
++x(префиксный) сначала увеличивается значение x на 1, а затем возвращается
x--
--x

52 Инстанциирование
создание объекта(экземпляра) класса

53 Инструкции выбора
if else if

54 Инструкции управления
if for while break continue switch case default

56 Интегрированная среда разработки
Редактор, компилятор, отладчик, система для управления версиями(git), управление проектом,
интеграция с внешними инструментами

57 Исключения, гарантии безопасности
void myFunction() noexcept {
    // код без возможности выброса исключений
}
Когда программа не выполняет какие-то обещанные или ожидаемые действия,
что может привести к нежелательным последствиям

Например, если функция обещает не вызывать исключений (например, в языке C++),
и в результате выполнения функции происходит исключение, это считается нарушением гарантии безопасности.

58 Исключения, обработка
Исключения - механизм обработки ошибок
try{
код который может вызвать исключение

catch {
Обработка исключений
 }
}

59 Использование параметров командной строки
int main(int argc, char *argv[]) {
    // код программы

    return 0;
}
argc - кол - во параметров командной строки
argv - массив строк, представляющих собой фактические параметры командной строки

60 Использование препроцессора
 препроцессор - это часть компилятора, которая выполняет текстовую обработку исходного кода перед компиляцией

Препроцессорные директивы начинаются с #
#define
#include <iostream>
#ifdef #endif

61 Итераторы
Итераторы в программировании - это объекты, предоставляющие доступ к элементам коллекции
(например, массива, списка, контейнера) и позволяющие перебирать эти элементы.
begin(): Возвращает итератор, указывающий на первый элемент коллекции.
end(): Возвращает итератор, указывающий за последний элемент коллекции.

62 Итераторы адаптирующие
1) std::reverse_iterator:
Адаптер, который создает итератор, перемещающийся по коллекции в обратном порядке.

std::vector<int> numbers = {1, 2, 3, 4, 5};

    // Создание обратного итератора
    auto rit = std::make_reverse_iterator(numbers.end());
2) std::ostream_iterator:
   Адаптер для итератора, который записывает значения в поток вывода.
    std::ostream_iterator<int> out_iter(std::cout, " ");
3) std::back_insert_iterator и std::front_insert_iterator:
   Адаптеры для вставки элементов в конец и начало контейнера соответственно.

64 Ключевое слово extern
extern int globalVar;  // Объявление внешней переменной, определенной в другом файле
extern void myFunction();  // Объявление внешней функции, определенной в другом файле

65 Ключевое слово override
Ключевое слово override в C++ используется для явного указания компилятору,
что функция в производном классе предназначена для переопределения (override) виртуальной функции базового класса.

class Base {
public:
    virtual void someFunction() const {
        // реализация в базовом классе
    }
};

class Derived : public Base {
public:
    void someFunction() const override {
        // переопределенная реализация в производном классе
    }
};


66 Ключевое слово template и typename
template - используется для создания шаблонов

// Пример шаблона функции
template <typename T>
T add(T a, T b) {
    return a + b;
}

typename - используется для указания, что определенный идентификатор является именем типа.

67 Ключевое слово this

Используется внутри методов класса и указывает на текущий объект, для которого вызывается метод.

void setX(int x) {
        // Использование this для разрешения конфликта имён
        this->x = x;
    }

    void printX() {
        // Использование this для доступа к члену класса
        std::cout << "Value of x: " << this->x << std::endl;
    }

68 Ключевое слово using
using namespace используется для подключения всех определений из пространства имён в текущее пространство имён.

69 Ключевое слово virtual
 C++ используется в контексте наследования и полиморфизма и применяется к методам в базовых классах.
  Когда функция объявляется как виртуальная, это означает,
  что эта функция может быть переопределена в производных классах,
  и вызов метода будет определен во время выполнения (в рантайме) в зависимости от типа объекта.

70 Таблицы кодирования и Unicode
ASCII - это стандартная кодовая таблица, разработанная для представления английского алфавита и основных символов.
Она включает в себя числовые значения от 0 до 127 и представляет каждый символ одним байтом.

Unicode - это многосимвольный набор кодирования,
который включает в себя широкий спектр символов различных языков и культур со всего мира
Unicode предоставляет множество различных кодировок,
таких как UTF-8, UTF-16 и UTF-32, которые используют разное количество байт для представления символов.

71 Композиция
композиция — это форма ассоциации,
которая позволяет создавать объекты более высокого уровня из других объектов, предоставляя им доступ к их членам

Создание объектов внутри другого объекта:

class Engine {
    // Реализация двигателя
};

class Car {
private:
    Engine carEngine; // Объект Engine создается внутри объекта Car
    // Другие члены класса Car
};
Сильная связь:

Композиция создает сильную связь между объектами.
Если объект, содержащий другие объекты, уничтожается, то и содержащиеся объекты также уничтожаются

72 Константность
Константная переменная — это переменная, значение которой не может быть изменено после ее инициализации.
const int  x = 4;
Константные функции:
void constFunction() const {
        // Запрещено изменять члены данных (кроме mutable)
    }
В константных функциях нельзя изменять члены данных объекта,
за исключением членов данных, объявленных с ключевым словом mutable.

Константный указатель
Константный указатель — это указатель, который нельзя использовать для изменения значения, на которое он указывает.
Константность помогает обеспечить безопасность и предсказуемость кода,
позволяя компилятору и программистам контролировать изменяемость переменных и состояния объектов.

73 Конструктор
Имя как у класса: Конструктор имеет то же имя, что и класс, в котором он определен.
Вызов при создании объекта: Когда вы создаете объект класса, конструктор автоматически вызывается для этого объекта.
Инициализация данных: Основная задача конструктора - инициализация членов данных объекта.
 Это позволяет задать начальные значения переменным класса.

74 Конструктор копирования
 - это специальная функция-член класса,
  предназначенная для создания нового объекта класса, который является копией существующего объекта того же класс
   MyClass(const MyClass& other) {
          // Логика копирования данных из объекта other в текущий объект
      }
75 Контейнеры в стандартной библиотеке
std::vector, std::list, std::deque, std::queue, std::stack, std::set, std::map
Они дают доступ до методов стека, дека и т.д

80 Манипуляторы и их использование
- специальный объект, вызывающий функцию потока
- стандартные манипуляторы определены в пространстве имён std
Например: std::endl; std::hex
Для использования манипулятора с параметрами в программе нужно включить заголовочный файл
#include <iomanip>

81 Машинное слово
фрагмент данных фиксированного размера,
обрабатываемый как единое целое с помощью набора команд или аппаратного обеспечения процессора

83 Модель памяти
Стек (Stack): Автоматически управляется и используется для хранения локальных переменных функций
и управления вызовами функций.
Память освобождается автоматически при выходе из блока, в котором создана переменная.

Куча (Heap): Динамическая память, которая управляется программистом.
Он используется для выделения памяти во время выполнения программы с помощью операторов
new и delete (или malloc и free в стиле C). Важно следить за освобождением памяти, чтобы избежать утечек.

Глобальная память (Static Memory): Память для глобальных переменных и статических переменных.
Глобальные переменные существуют на протяжении всего времени выполнения программы.

84 Ноль
Инициализация переменных:
int x = 0;
Сравнение с нулём:
if (x == 0) {}
Использование в массивах:
int arr[4] = {0, 1, 3, 4}

86 Обобщённое программирование
Обобщённое программирование — парадигма программирования, при которой алгоритмы пишутся
 в универсальном виде с использованием шаблонов, что позволяет им работать с различными типами данных

Один и тот же алгоритм может работать с разными типами данных


